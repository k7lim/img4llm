{"id":"img4llm-f6d","title":"Add CLI bin entry to package.json","description":"## Context\n- package.json (L1-39): current config has no bin field\n- build.config.ts (L1-21): uses `pattern: \\\"*.ts\\\"` on `input: \\\"src/\\\"` — this wildcard already covers any new .ts file in src/, so NO changes needed to build.config.ts\n\n## Task\nAdd a `\\\"bin\\\"` field to package.json so that `npm install -g` wires up the CLI:\n\n```json\n\"bin\": {\n  \"img4llm\": \"lib/cli.cjs\"\n},\n```\n\nInsert it after the `\\\"types\\\"` field (after L14). Use the CJS entry since bin scripts must work without ESM loader flags.\n\nAlso add `\\\"src\\\"` to the `\\\"files\\\"` array (L15-19) so source maps/debugging work when installed globally. The files array should become: `[\\\"README.md\\\", \\\"LICENSE\\\", \\\"lib\\\", \\\"src\\\"]`.\n\n## Verification\n1. `node -e \"const p = require('./package.json'); console.assert(p.bin['img4llm'] === 'lib/cli.cjs', 'bin field missing')\"` — passes\n2. `node -e \"JSON.parse(require('fs').readFileSync('package.json','utf8'))\"` — valid JSON\n3. No other fields in package.json are modified","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T20:47:02.029275986Z","created_by":"unknown","updated_at":"2026-02-08T20:47:02.029275986Z"}
{"id":"img4llm-pna","title":"Create src/cli.ts — full CLI implementation","description":"## Context — Read these before starting\n- src/index.ts:L26-31 — OptimizeOptions interface (maxDimension, quality, generateCaption, captionModel)\n- src/index.ts:L33-39 — OptimizeResult interface (buffer, metadata, strategy, mimeType, caption?)\n- src/index.ts:L14-18 — ImageStrategy enum (RASTER_OPTIMIZE, CONVERT_TO_SVG, KEEP_AS_IS)\n- src/index.ts:L6-12 — ImageMetadata interface (dimensions, format, filesize, distinctColors, aspectRatio)\n- src/index.ts:L20-24 — ImageAnalysisResult interface (metadata, strategy, confidence)\n- src/index.ts:L175-198 — optimizeForLLM() main entry point\n- src/index.ts:L91-95 — analyzeImage() returns ImageAnalysisResult\n- package.json:L5 — project is \"type\": \"module\" (ESM)\n- build.config.ts:L1-21 — unbuild compiles src/*.ts to lib/ in both ESM and CJS\n\n## Code style (match src/index.ts)\n- TypeScript, ESM imports\n- Async/await, no callbacks\n- Minimal dependencies (only sharp + node builtins)\n- Section separators: // --- Section Name ---\n\n## Task\nCreate src/cli.ts — the complete CLI for img4llm. Requirements:\n\n### 1. File structure\n```\n#!/usr/bin/env node\n```\nShebang MUST be the very first line (byte 0 of file).\n\n### 2. Imports\n```typescript\nimport { parseArgs } from 'node:util'\nimport { readFile, writeFile, stat } from 'node:fs/promises'\nimport { resolve, basename, extname, join, dirname } from 'node:path'\nimport { glob } from 'node:fs'\nimport { optimizeForLLM, analyzeImage, ImageStrategy } from './index'\nimport type { OptimizeOptions } from './index'\n```\nNote: if node:fs glob is unavailable (Node \u003c22), fall back to accepting only literal paths (no glob expansion). The shell expands unquoted globs anyway, so this is fine.\n\n### 3. Arg parsing with node:util parseArgs\n```typescript\nconst { values, positionals } = parseArgs({\n  args: process.argv.slice(2),\n  options: {\n    'max-dimension': { type: 'string', short: 'd' },\n    quality:         { type: 'string', short: 'q' },\n    caption:         { type: 'boolean', short: 'c' },\n    'caption-model': { type: 'string', short: 'm' },\n    output:          { type: 'string', short: 'o' },\n    json:            { type: 'boolean' },\n    help:            { type: 'boolean', short: 'h' },\n  },\n  allowPositionals: true,\n})\n```\n\n### 4. Help text\nWhen --help or no args, print usage and exit(0):\n```\nUsage: img4llm [command] \u003cfile...\u003e\n\nCommands:\n  optimize \u003cfile...\u003e   Optimize image(s) for LLM vision (default)\n  analyze  \u003cfile\u003e      Analyze image and print metadata + strategy\n\nOptions:\n  -d, --max-dimension \u003cpx\u003e   Max width/height (default: 768)\n  -q, --quality \u003c1-100\u003e      JPEG quality (default: 85)\n  -c, --caption              Generate caption via Ollama\n  -m, --caption-model \u003cname\u003e Ollama model (default: qwen3-vl:4b)\n  -o, --output \u003cpath\u003e        Output path (single file only)\n      --json                 Machine-readable JSON output\n  -h, --help                 Show this help\n```\n\n### 5. Command dispatch\n- First positional is checked: if it's \"optimize\" or \"analyze\", consume it as the command, rest are file args.\n- If first positional is NOT a known command, treat ALL positionals as files and default command = \"optimize\".\n- If no files after dispatch, print help and exit(1).\n\n### 6. Optimize command handler\nFor each file path:\n1. `await readFile(resolve(path))` to get a Buffer\n2. Build OptimizeOptions from parsed flags: `{ maxDimension: Number(values['max-dimension']) || undefined, quality: Number(values.quality) || undefined, generateCaption: values.caption, captionModel: values['caption-model'] }`\n3. Call `await optimizeForLLM(buffer, opts)`\n4. Determine output path: if --output is set (only valid for single file), use that. Otherwise: replace extension with `.optimized.jpg` (since optimize always produces JPEG for non-SVG). E.g., `photo.png` → `photo.optimized.jpg`. For KEEP_AS_IS strategy, keep original extension: `icon.svg` → `icon.optimized.svg`.\n5. `await writeFile(outputPath, result.buffer)`\n6. Print summary line: `✓ photo.png → photo.optimized.jpg (RASTER_OPTIMIZE, 2.1MB → 89KB)`\n   Format sizes with KB/MB units. Show strategy name.\n   If caption was generated, print it on the next line: `  caption: \"A photo of...\"`\n\nProcess files in parallel with `Promise.all` (or `Promise.allSettled` for resilience).\n\nIf --json, collect all results into an array and print a single JSON blob at the end:\n```json\n[{\n  \"input\": \"photo.png\",\n  \"output\": \"photo.optimized.jpg\",\n  \"strategy\": \"RASTER_OPTIMIZE\",\n  \"inputSize\": 2100000,\n  \"outputSize\": 89000,\n  \"dimensions\": { \"width\": 768, \"height\": 512 },\n  \"caption\": \"A photo of...\"\n}]\n```\n\n### 7. Analyze command handler\nFor each file:\n1. `await readFile(resolve(path))` to get a Buffer\n2. Call `await analyzeImage(buffer)`\n3. Print JSON to stdout (always JSON, --json flag not needed):\n```json\n{\n  \"file\": \"photo.png\",\n  \"metadata\": { ... },\n  \"strategy\": \"RASTER_OPTIMIZE\",\n  \"confidence\": 1\n}\n```\nIf multiple files, print one JSON object per line (JSONL).\n\n### 8. Error handling\n- Wrap each file operation in try/catch. On error, print to stderr: `✗ photo.png: ENOENT: no such file or directory`\n- If ALL files fail, exit(1). If some succeed, exit(0) but print errors to stderr.\n- For invalid flag values (e.g., --quality abc), print error and exit(1).\n\n### 9. Glob expansion\nIf a positional arg contains `*`, `?`, or `[`, attempt glob expansion:\n- Try `import { glob } from 'node:fs'` (Node 22+). If unavailable, try a simple readdir+filter approach on the directory.\n- If no matches, print warning to stderr and skip.\n\n## Verification\n1. `npx tsc --noEmit src/cli.ts` — compiles without errors\n2. First line of src/cli.ts is exactly `#!/usr/bin/env node`\n3. The file imports from './index' (relative, no 'img4llm')\n4. No new dependencies added (only node: builtins + existing imports from ./index)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-08T20:47:44.098224498Z","created_by":"unknown","updated_at":"2026-02-08T12:56:52.406954-10:00","closed_at":"2026-02-08T12:56:52.406954-10:00","close_reason":"Implemented complete CLI in src/cli.ts with optimize/analyze commands, parseArgs arg parsing, glob expansion, JSON output, error handling, and size formatting"}
{"id":"img4llm-siy","title":"Build, verify shebang survives unbuild, chmod, smoke test","description":"## Context\n- build.config.ts (L1-21) — unbuild config, uses rollup internally. The pattern \\\"*.ts\\\" on input \\\"src/\\\" will compile src/cli.ts → lib/cli.cjs + lib/cli.mjs.\n- package.json \\\"bin\\\" field (added by task img4llm-f6d) points to lib/cli.cjs\n- src/cli.ts (created by task img4llm-pna) starts with #!/usr/bin/env node shebang\n\n## Problem to solve\nunbuild (rollup) may strip the shebang line during compilation. This task must verify it survives and fix if it doesn't.\n\n## Task\n\n### Step 1: Build\nRun \\`pnpm build\\` and verify it completes without errors.\n\n### Step 2: Verify shebang\nCheck that lib/cli.cjs starts with \\`#!/usr/bin/env node\\`:\n\\`\\`\\`bash\nhead -c 21 lib/cli.cjs\n\\`\\`\\`\nExpected: \\`#!/usr/bin/env node\\n\\`\n\nIf the shebang is MISSING:\n- Option A: Add a banner to build.config.ts. In the CJS entry for cli, add:\n  \\`\\`\\`typescript\n  { input: \\\"src/cli.ts\\\", outDir: \\\"lib/\\\", format: \\\"cjs\\\", ext: \\\"cjs\\\", declaration: false }\n  \\`\\`\\`\n  with a rollup banner option. However, unbuild's support for per-entry rollup options is limited.\n- Option B (preferred): Add a postbuild script to package.json:\n  \\`\\`\\`json\n  \\\"postbuild\\\": \\\"node -e \\\\\\\"const fs=require('fs');const f='lib/cli.cjs';const c=fs.readFileSync(f,'utf8');if(!c.startsWith('#!'))fs.writeFileSync(f,'#!/usr/bin/env node\\\\\\\\n'+c)\\\\\\\"\\\"\n  \\`\\`\\`\n- Option C: Use sed in a postbuild script: \\`sed -i '1i#!/usr/bin/env node' lib/cli.cjs\\` (only if shebang missing)\n\n### Step 3: chmod\n\\`\\`\\`bash\nchmod +x lib/cli.cjs\n\\`\\`\\`\n\n### Step 4: Smoke test\n\\`\\`\\`bash\nnode lib/cli.cjs --help\n\\`\\`\\`\nExpected: prints usage text starting with \\\"Usage: img4llm\\\", exits 0.\n\n\\`\\`\\`bash\n# Create a test image and run optimize\nnode -e \\\"require('sharp')({create:{width:100,height:100,channels:3,background:{r:255,g:0,b:0}}}).png().toFile('/tmp/img4llm-test.png')\\\" \u0026\u0026 node lib/cli.cjs /tmp/img4llm-test.png \u0026\u0026 ls -la /tmp/img4llm-test.optimized.jpg\n\\`\\`\\`\nExpected: output file created, summary line printed.\n\n### Step 5: Run full test suite\n\\`\\`\\`bash\npnpm test\n\\`\\`\\`\nAll tests (test/index.spec.ts and test/cli.spec.ts) must pass.\n\n## Verification\n1. \\`pnpm build\\` exits 0\n2. lib/cli.cjs exists and starts with \\`#!/usr/bin/env node\\`\n3. lib/cli.cjs is executable (\\`test -x lib/cli.cjs\\`)\n4. \\`node lib/cli.cjs --help\\` prints usage and exits 0\n5. \\`pnpm test\\` — all tests pass\n6. Smoke test: optimize a real image file successfully","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T20:48:44.495030927Z","created_by":"unknown","updated_at":"2026-02-08T20:48:44.495030927Z","dependencies":[{"issue_id":"img4llm-siy","depends_on_id":"img4llm-f6d","type":"blocks","created_at":"2026-02-08T20:49:00.60227533Z","created_by":"unknown"},{"issue_id":"img4llm-siy","depends_on_id":"img4llm-pna","type":"blocks","created_at":"2026-02-08T20:49:07.707789153Z","created_by":"unknown"},{"issue_id":"img4llm-siy","depends_on_id":"img4llm-zn6","type":"blocks","created_at":"2026-02-08T20:49:14.389581715Z","created_by":"unknown"}]}
{"id":"img4llm-zn6","title":"Write CLI integration tests","description":"## Context — Read these before starting\n- src/cli.ts — the CLI implementation (created by task img4llm-pna). Read it fully to understand the actual interface.\n- test/index.spec.ts (L1-42) — existing test patterns: uses sharp to create fixture images, jest, ts-jest preset\n- jest.config.ts — preset: ts-jest, testEnvironment: node\n- src/index.ts:L14-18 — ImageStrategy enum values\n- src/index.ts:L6-12 — ImageMetadata shape (for analyze output assertions)\n\n## Task\nCreate test/cli.spec.ts — integration tests for the CLI. Tests should invoke the CLI as a subprocess (like a user would) using node child_process.\n\n### Test approach\nUse `execFile` (from node:child_process, promisified) to run `npx tsx src/cli.ts` with args. This tests the actual CLI behavior without needing a build step. Alternatively, if tsx is not available, use `node --loader ts-node/esm src/cli.ts`.\n\n### Setup helper\n```typescript\nimport { execFile as execFileCb } from 'node:child_process'\nimport { promisify } from 'node:util'\nimport { mkdtemp, writeFile, readFile, rm } from 'node:fs/promises'\nimport { tmpdir } from 'node:os'\nimport { join } from 'node:path'\nimport sharp from 'sharp'\n\nconst execFile = promisify(execFileCb)\nconst CLI = join(__dirname, '..', 'src', 'cli.ts')\nconst run = (args: string[]) =\u003e execFile('npx', ['tsx', CLI, ...args], { timeout: 30000 })\n```\n\nCreate a temp dir in beforeAll with test fixture images:\n- `test.png` — 200x200 solid red PNG (via sharp)\n- `large.png` — 2000x1500 gradient PNG (many colors, triggers RASTER_OPTIMIZE)\n- `tiny.png` — 10x10 solid blue PNG (few colors, small, triggers CONVERT_TO_SVG)\n\nClean up temp dir in afterAll.\n\n### Required test cases\n\n1. **--help flag prints usage and exits 0**\n   - `run(['--help'])` → stdout contains \"Usage: img4llm\", exitCode 0\n\n2. **No args prints help to stderr and exits 1**\n   - `run([])` → rejects with exitCode 1, stderr contains \"Usage\"\n\n3. **optimize single file (default command)**\n   - `run([testPng])` → creates `test.optimized.jpg` in same dir, stdout contains strategy name and arrow, exit 0\n   - Verify output file exists and is valid JPEG (read with sharp, check format)\n\n4. **optimize with explicit subcommand**\n   - `run(['optimize', testPng])` → same behavior as above\n\n5. **optimize with --output flag**\n   - `run([testPng, '--output', join(tmpDir, 'custom.jpg')])` → writes to custom.jpg\n\n6. **optimize with --max-dimension and --quality**\n   - `run([largePng, '-d', '256', '-q', '50'])` → output image max dimension ≤ 256\n\n7. **optimize with --json flag**\n   - `run([testPng, '--json'])` → stdout is valid JSON array, each element has: input, output, strategy, inputSize, outputSize, dimensions\n\n8. **optimize multiple files**\n   - `run([testPng, largePng])` → both .optimized.jpg files created\n\n9. **analyze subcommand**\n   - `run(['analyze', testPng])` → stdout is valid JSON with metadata.dimensions, strategy, confidence fields\n\n10. **analyze multiple files (JSONL)**\n    - `run(['analyze', testPng, largePng])` → two lines of valid JSON\n\n11. **missing file prints error to stderr**\n    - `run(['nonexistent.png'])` → rejects, stderr contains \"nonexistent.png\"\n\n12. **handles KEEP_AS_IS strategy (SVG-like)**\n    - Create a small, few-color PNG and verify the output extension logic\n\n### Important notes\n- Each test should use isolated output paths (use the temp dir) to avoid conflicts\n- Clean up generated .optimized.* files between tests if needed\n- Tests must pass with: `pnpm test` (jest discovers test/cli.spec.ts automatically)\n- Timeout: set jest timeout to 30s for these tests since they spawn subprocesses\n\n## Verification\n1. `pnpm test` — all tests pass (both test/index.spec.ts and test/cli.spec.ts)\n2. At least 10 test cases in test/cli.spec.ts\n3. Tests cover: help, optimize (single, multi, flags), analyze, errors, --json","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T20:48:17.581548822Z","created_by":"unknown","updated_at":"2026-02-08T20:48:17.581548822Z","dependencies":[{"issue_id":"img4llm-zn6","depends_on_id":"img4llm-pna","type":"blocks","created_at":"2026-02-08T20:48:54.534094998Z","created_by":"unknown"}]}
